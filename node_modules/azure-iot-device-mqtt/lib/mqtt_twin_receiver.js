// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var azure_iot_mqtt_base_1 = require("azure-iot-mqtt-base");
var querystring = require("querystring");
var url = require("url");
var machina = require("machina");
var dbg = require("debug");
var debug = dbg('azure-iot-device-mqtt:MqttTwinReceiver');
// $iothub/twin/PATCH/properties/reported/?$rid={request id}&$version={base version}
/* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_009: [** The subscribed topic for `response` events shall be '$iothub/twin/res/#' **]** */
var responseTopic = '$iothub/twin/res/#';
/* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_019: [** The subscribed topic for post events shall be $iothub/twin/PATCH/properties/desired/# **]** */
var postTopic = '$iothub/twin/PATCH/properties/desired/#';
/**
 * @private
 * @class        module:azure-iot-device-mqtt.MqttTwinReceiver
 * @classdesc    Acts as a receiver for device-twin traffic
 *
 * @param {Object} config   configuration object
 * @fires MqttTwinReceiver#subscribed   an MQTT topic has been successfully subscribed to
 * @fires MqttTwinReceiver#error    an error has occured while subscribing to an MQTT topic
 * @fires MqttTwinReceiver#response   a response message has been received from the service
 * @fires MqttTwinReceiver#post a post message has been received from the service
 * @throws {ReferenceError} If client parameter is falsy.
 *
 */
var MqttTwinReceiver = /** @class */ (function (_super) {
    __extends(MqttTwinReceiver, _super);
    function MqttTwinReceiver(client) {
        var _this = _super.call(this) || this;
        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_001: [** The `MqttTwinReceiver` constructor shall accept a `client` object **]** */
        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_002: [** The `MqttTwinReceiver` constructor shall throw `ReferenceError` if the `client` object is falsy **]** */
        if (!client) {
            throw new ReferenceError('required parameter is missing');
        }
        _this._mqtt = client;
        _this.on('newListener', function (eventName) {
            if (eventName === MqttTwinReceiver.responseEvent || eventName === MqttTwinReceiver.postEvent) {
                /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_003: [** When a listener is added for the `response` event, the appropriate topic shall be asynchronously subscribed to. **]** */
                _this._fsm.handle('subscribe', function (err) {
                    if (err) {
                        debug('error while subscribing: ' + err.toString());
                        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_023: [** If the `error` event is subscribed to, an `error` event shall be emitted if any asynchronous subscribing operations fails. **]** */
                        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_024: [** When the `error` event is emitted, the first parameter shall be an error object obtained via the MQTT `translateError` module. **]** */
                        _this.emit(MqttTwinReceiver.errorEvent, azure_iot_mqtt_base_1.translateError(err));
                    }
                });
            }
        });
        _this.on('removeListener', function (eventName) {
            if (eventName === MqttTwinReceiver.responseEvent || eventName === MqttTwinReceiver.postEvent) {
                if (_this.listeners('response').length + _this.listeners('post').length <= 0) {
                    _this._fsm.handle('unsubscribe', function (err) {
                        if (err) {
                            debug('error while unsubscribing: ' + err.toString());
                            /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_024: [** When the `error` event is emitted, the first parameter shall be an error object obtained via the MQTT `translateError` module. **]** */
                            _this.emit(MqttTwinReceiver.errorEvent, azure_iot_mqtt_base_1.translateError(err));
                        }
                    });
                }
            }
        });
        var messageHandler = _this._onMqttMessage.bind(_this);
        _this._fsm = new machina.Fsm({
            namespace: 'device-mqtt',
            initialState: 'unsubscribed',
            states: {
                unsubscribed: {
                    _onEnter: function (callback, err) {
                        _this._mqtt.removeListener('message', messageHandler);
                        if (callback) {
                            callback(err);
                        }
                        else if (err) {
                            _this.emit('error', azure_iot_mqtt_base_1.translateError(err));
                        }
                    },
                    subscribe: function (callback) { return _this._fsm.transition('subscribingToResponseTopic', callback); },
                    unsubscribe: function (callback) { return callback(); }
                },
                subscribingToResponseTopic: {
                    _onEnter: function (callback) {
                        debug('subscribing to response topic');
                        _this._mqtt.on('message', messageHandler);
                        _this._mqtt.subscribe(responseTopic, { qos: 0 }, function (err, responseTopicResult) {
                            if (err) {
                                _this._fsm.transition('unsubscribed', callback, err);
                            }
                            else {
                                debug('subscribed to response topic');
                                _this._fsm.transition('subscribingToPostTopic', callback, responseTopicResult);
                            }
                        });
                    },
                    '*': function () { return _this._fsm.deferUntilTransition(); }
                },
                subscribingToPostTopic: {
                    _onEnter: function (callback, responseTopicResult) {
                        debug('subscribed to post topic');
                        _this._mqtt.subscribe(postTopic, { qos: 0 }, function (err, postTopicResult) {
                            if (err) {
                                _this._fsm.transition('unsubscribingFromResponseTopic', callback, err);
                            }
                            else {
                                debug('subscribed to post topic');
                                _this._fsm.transition('subscribed', callback, responseTopicResult, postTopicResult);
                            }
                        });
                    },
                    '*': function () { return _this._fsm.deferUntilTransition(); }
                },
                subscribed: {
                    _onEnter: function (callback, responseTopicResult, postTopicResult) {
                        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_025: [** If the `subscribed` event is subscribed to, a `subscribed` event shall be emitted after an MQTT topic is subscribed to. **]** */
                        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_028: [** When the `subscribed` event is emitted, the parameter shall be an object which contains an `eventName` field and an `transportObject` field. **]** */
                        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_026: [** When the `subscribed` event is emitted because the response MQTT topic was subscribed, the parameter shall be the string 'response' **]**  */
                        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_029: [** When the subscribed event is emitted, the `transportObject` field shall contain the object returned by the library in the subscription response. **]** */
                        _this.emit(MqttTwinReceiver.subscribedEvent, { 'eventName': MqttTwinReceiver.responseEvent, 'transportObject': responseTopicResult });
                        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_025: [** If the `subscribed` event is subscribed to, a `subscribed` event shall be emitted after an MQTT topic is subscribed to. **]** */
                        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_028: [** When the `subscribed` event is emitted, the parameter shall be an object which contains an `eventName` field and an `transportObject` field. **]** */
                        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_027: [** When the `subscribed` event is emitted because the post MQTT topic was subscribed, the `eventName` field shall be the string 'post' **]** */
                        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_029: [** When the subscribed event is emitted, the `transportObject` field shall contain the object returned by the library in the subscription response. **]** */
                        _this.emit(MqttTwinReceiver.subscribedEvent, { 'eventName': MqttTwinReceiver.postEvent, 'transportObject': postTopicResult });
                        callback();
                    },
                    subscribe: function (callback) { return callback(); },
                    unsubscribe: function (callback) { return _this._fsm.transition('unsubscribingFromPostTopic', callback); }
                },
                unsubscribingFromPostTopic: {
                    _onEnter: function (callback) {
                        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_021: [** When there are no more listeners for the post event, the topic should be unsubscribed. **]** */
                        _this._mqtt.unsubscribe(postTopic, function (err) {
                            _this._fsm.transition('unsubscribingFromResponseTopic', callback, err);
                        });
                    },
                    '*': function () { return _this._fsm.deferUntilTransition(); }
                },
                unsubscribingFromResponseTopic: {
                    _onEnter: function (callback, forwardedError) {
                        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_005: [** When there are no more listeners for the `response` event, the topic should be unsubscribed **]** */
                        _this._mqtt.unsubscribe(responseTopic, function (err) {
                            var finalError = forwardedError || err;
                            _this._fsm.transition('unsubscribed', callback, finalError);
                        });
                    },
                    '*': function () { return _this._fsm.deferUntilTransition(); }
                }
            }
        });
        return _this;
    }
    MqttTwinReceiver.prototype.subscribe = function (callback) {
        this._fsm.handle('subscribe', callback);
    };
    MqttTwinReceiver.prototype.unsubscribe = function (callback) {
        this._fsm.handle('unsubscribe', callback);
    };
    MqttTwinReceiver.prototype._onMqttMessage = function (topic, message) {
        debug('mqtt message received');
        if (topic.indexOf('$iothub/twin/res') === 0) {
            debug('response message received');
            this._onResponseMessage(topic, message);
        }
        else if (topic.indexOf('$iothub/twin/PATCH') === 0) {
            debug('post message received');
            this._onPostMessage(topic, message);
        }
        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_014: [** Any messages received on topics which violate the topic name formatting shall be ignored. **]** */
    };
    MqttTwinReceiver.prototype._onResponseMessage = function (topic, message) {
        var urlObject;
        var path;
        var query;
        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_014: [** Any messages received on topics which violate the topic name formatting shall be ignored. **]** */
        try {
            urlObject = url.parse(topic);
            path = urlObject.path.split('/');
            query = querystring.parse(urlObject.query);
        }
        catch (err) {
            return;
        }
        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_006: [** When a `response` event is emitted, the parameter shall be an object which contains `status`, `requestId` and `body` members **]**  */
        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_010: [** The topic which receives the response shall be formatted as '$iothub/twin/res/{status}/?$rid={request id}' **]** */
        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_015: [** the {status} and {request id} fields in the topic name are required. **]** */
        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_016: [** The {status} and {request id} fields in the topic name shall be strings **]** */
        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_017: [** The {status} and {request id} fields in the topic name cannot be zero length. **]** */
        if ((path[0] === '$iothub') &&
            (path[1] === 'twin') &&
            (path[2] === 'res') &&
            (path[3]) &&
            (path[3].toString().length > 0) &&
            (query.$rid) &&
            (query.$rid.toString().length > 0)) {
            /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_011: [** The `status` parameter of the `response` event shall be parsed out of the topic name from the {status} field **]** */
            /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_012: [** The `requestId` parameter of the `response` event shall be parsed out of the topic name from the {request id} field **]** */
            /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_013: [** The `body` parameter of the `response` event shall be the body of the received MQTT message **]**  */
            /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_011: [** The `status` parameter of the `response` event shall be parsed out of the topic name from the {status} field **]** */
            /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_012: [** The `requestId` parameter of the `response` event shall be parsed out of the topic name from the {request id} field **]** */
            /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_013: [** The `body` parameter of the `response` event shall be the body of the received MQTT message **]**  */
            var response = {
                'topic': topic,
                'status': Number(path[3]),
                '$rid': query.$rid,
                'body': message
            };
            /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_004: [** If there is a listener for the `response` event, a `response` event shall be emitted for each response received. **]** */
            this.emit(MqttTwinReceiver.responseEvent, response);
        }
    };
    MqttTwinReceiver.prototype._onPostMessage = function (topic, message) {
        /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_020: [** If there is a listener for the post event, a post event shal be emitteded for each post message received **]** */
        if (topic.indexOf('$iothub/twin/PATCH/properties/desired') === 0) {
            /* Codes_SRS_NODE_DEVICE_MQTT_TWIN_RECEIVER_18_022: [** When a post event it emitted, the parameter shall be the body of the message **]** */
            this.emit(MqttTwinReceiver.postEvent, message);
        }
    };
    MqttTwinReceiver.errorEvent = 'error';
    MqttTwinReceiver.responseEvent = 'response';
    MqttTwinReceiver.postEvent = 'post';
    MqttTwinReceiver.subscribedEvent = 'subscribed';
    return MqttTwinReceiver;
}(events_1.EventEmitter));
exports.MqttTwinReceiver = MqttTwinReceiver;
//# sourceMappingURL=mqtt_twin_receiver.js.map