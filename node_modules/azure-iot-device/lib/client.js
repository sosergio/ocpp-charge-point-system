// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var dbg = require("debug");
var debug = dbg('azure-iot-device:Client');
var azure_iot_common_1 = require("azure-iot-common");
var azure_iot_common_2 = require("azure-iot-common");
var ConnectionString = require("./connection_string.js");
var SharedAccessSignature = require("./shared_access_signature.js");
var blob_upload_1 = require("./blob_upload");
var device_method_1 = require("./device_method");
/**
 * @private
 * Default maximum operation timeout for client operations: 4 minutes.
 */
var MAX_OPERATION_TIMEOUT = 240000;
function safeCallback(callback, error, result) {
    if (callback)
        callback(error, result);
}
/**
 * IoT Hub device client used to connect a device with an Azure IoT hub.
 *
 * Users of the SDK should call one of the factory methods,
 * {@link azure-iot-device.Client.fromConnectionString|fromConnectionString}
 * or {@link azure-iot-device.Client.fromSharedAccessSignature|fromSharedAccessSignature}
 * to create an IoT Hub device client.
 */
var Client = /** @class */ (function (_super) {
    __extends(Client, _super);
    /**
     * @constructor
     * @param {Object}  transport         An object that implements the interface
     *                                    expected of a transport object, e.g.,
     *                                    {@link azure-iot-device-http.Http|Http}.
     * @param {string}  connStr           A connection string (optional: when not provided, updateSharedAccessSignature must be called to set the SharedAccessSignature token directly).
     * @param {Object}  blobUploadClient  An object that is capable of uploading a stream to a blob.
     */
    function Client(transport, connStr, blobUploadClient) {
        var _this = this;
        /*Codes_SRS_NODE_DEVICE_CLIENT_05_001: [The Client constructor shall throw ReferenceError if the transport argument is falsy.]*/
        if (!transport)
            throw new ReferenceError('transport is \'' + transport + '\'');
        _this = _super.call(this) || this;
        _this._c2dEnabled = false;
        _this._methodsEnabled = false;
        /*Codes_SRS_NODE_DEVICE_CLIENT_16_026: [The Client constructor shall accept a connection string as an optional second argument] */
        _this._connectionString = connStr;
        /*Codes_SRS_NODE_DEVICE_CLIENT_16_027: [If a connection string argument is provided and is using SharedAccessKey authentication, the Client shall automatically generate and renew SAS tokens.] */
        _this._useAutomaticRenewal = !!(_this._connectionString && ConnectionString.parse(_this._connectionString).SharedAccessKey);
        _this.blobUploadClient = blobUploadClient;
        _this._transport = transport;
        _this._transport.on('message', function (msg) {
            _this.emit('message', msg);
        });
        _this._transport.on('error', function (err) {
            // errors right now bubble up through the disconnect handler.
            // ultimately we would like to get rid of that disconnect event and rely on the error event instead
            debug('Transport error: ' + err.toString());
        });
        _this._methodCallbackMap = {};
        _this.on('removeListener', function (eventName) {
            if (eventName === 'message' && _this.listeners('message').length === 0) {
                _this._disableC2D(function (err) {
                    if (err) {
                        _this.emit('error', err);
                    }
                });
            }
        });
        _this.on('newListener', function (eventName) {
            if (eventName === 'message') {
                _this._enableC2D(function (err) {
                    if (err) {
                        _this.emit('error', err);
                    }
                });
            }
        });
        if (_this._useAutomaticRenewal) {
            _this._sasRenewalTimeout = setTimeout(_this._renewSharedAccessSignature.bind(_this), Client.sasRenewalInterval);
        }
        _this._disconnectHandler = function (err) {
            debug('transport disconnect event: ' + (err ? err.toString() : 'no error'));
            if (err && _this._retryPolicy.shouldRetry(err)) {
                if (_this._c2dEnabled) {
                    _this._c2dEnabled = false;
                    debug('re-enabling C2D link');
                    _this._enableC2D(function (err) {
                        if (err) {
                            _this.emit('disconnect', new azure_iot_common_1.results.Disconnected(err));
                        }
                    });
                }
                if (_this._methodsEnabled) {
                    _this._methodsEnabled = false;
                    debug('re-enabling Methods link');
                    _this._enableMethods(function (err) {
                        if (err) {
                            _this.emit('disconnect', new azure_iot_common_1.results.Disconnected(err));
                        }
                    });
                }
            }
            else {
                _this.emit('disconnect', new azure_iot_common_1.results.Disconnected(err));
            }
        };
        /*Codes_SRS_NODE_DEVICE_CLIENT_16_045: [If the transport successfully establishes a connection the `open` method shall subscribe to the `disconnect` event of the transport.]*/
        _this._transport.on('disconnect', _this._disconnectHandler);
        _this._retryPolicy = new azure_iot_common_2.ExponentialBackOffWithJitter();
        _this._maxOperationTimeout = MAX_OPERATION_TIMEOUT;
        return _this;
    }
    /**
     * @method            module:azure-iot-device.Client#onDeviceMethod
     * @description       Registers the `callback` to be invoked when a
     *                    cloud-to-device method call is received by the client
     *                    for the given `methodName`.
     *
     * @param {String}   methodName   The name of the method for which the callback
     *                                is to be registered.
     * @param {Function} callback     The callback to be invoked when the C2D method
     *                                call is received.
     *
     * @throws {ReferenceError}       If the `methodName` or `callback` parameter
     *                                is falsy.
     * @throws {TypeError}            If the `methodName` parameter is not a string
     *                                or if the `callback` is not a function.
     */
    Client.prototype.onDeviceMethod = function (methodName, callback) {
        var _this = this;
        // validate input args
        this._validateDeviceMethodInputs(methodName, callback);
        this._methodCallbackMap[methodName] = callback;
        this._addMethodCallback(methodName, callback);
        this._enableMethods(function (err) {
            if (err) {
                _this.emit('error', err);
            }
        });
    };
    /*Codes_SRS_NODE_DEVICE_CLIENT_05_016: [When a Client method encounters an error in the transport, the callback function (indicated by the done argument) shall be invoked with the following arguments:
    err - the standard JavaScript Error object, with a response property that points to a transport-specific response object, and a responseBody property that contains the body of the transport response.]*/
    /*Codes_SRS_NODE_DEVICE_CLIENT_05_017: [With the exception of receive, when a Client method completes successfully, the callback function (indicated by the done argument) shall be invoked with the following arguments:
    err - null
    response - a transport-specific response object]*/
    /**
     * @method            module:azure-iot-device.Client#updateSharedAccessSignature
     * @description       Updates the Shared Access Signature token used by the transport to authenticate with the IoT Hub service.
     *
     * @param {String}   sharedAccessSignature   The new SAS token to use.
     * @param {Function} done       The callback to be invoked when `updateSharedAccessSignature`
     *                              completes execution.
     *
     * @throws {ReferenceError}     If the sharedAccessSignature parameter is falsy.
     * @throws {ReferenceError}     If the client uses x509 authentication.
     */
    Client.prototype.updateSharedAccessSignature = function (sharedAccessSignature, updateSasCallback) {
        var _this = this;
        /*Codes_SRS_NODE_DEVICE_CLIENT_16_031: [The updateSharedAccessSignature method shall throw a ReferenceError if the sharedAccessSignature parameter is falsy.]*/
        if (!sharedAccessSignature)
            throw new ReferenceError('sharedAccessSignature is falsy');
        if (this._useAutomaticRenewal)
            debug('calling updateSharedAccessSignature while using automatic sas renewal');
        /*Codes_SRS_NODE_DEVICE_CLIENT_06_002: [The `updateSharedAccessSignature` method shall throw a `ReferenceError` if the client was created using x509.]*/
        if (this._connectionString && ConnectionString.parse(this._connectionString).x509)
            throw new ReferenceError('client uses x509');
        this.blobUploadClient.updateSharedAccessSignature(sharedAccessSignature);
        var retryOp = new azure_iot_common_2.RetryOperation(this._retryPolicy, this._maxOperationTimeout);
        retryOp.retry(function (opCallback) {
            _this._transport.updateSharedAccessSignature(sharedAccessSignature, opCallback);
        }, function (err, result) {
            if (!err) {
                _this.emit('_sharedAccessSignatureUpdated');
            }
            safeCallback(updateSasCallback, err, result);
        });
    };
    /**
     * @method            module:azure-iot-device.Client#open
     * @description       Call the transport layer CONNECT function if the
     *                    transport layer implements it
     *
     * @param {Function} openCallback  The callback to be invoked when `open`
     *                                 completes execution.
     */
    Client.prototype.open = function (openCallback) {
        var _this = this;
        var retryOp = new azure_iot_common_2.RetryOperation(this._retryPolicy, this._maxOperationTimeout);
        retryOp.retry(function (opCallback) {
            _this._transport.connect(opCallback);
        }, function (connectErr, connectResult) {
            /*Codes_SRS_NODE_DEVICE_CLIENT_16_060: [The `open` method shall call the `openCallback` callback with a null error object and a `results.Connected()` result object if the transport is already connected, doesn't need to connect or has just connected successfully.]*/
            safeCallback(openCallback, connectErr, connectResult);
        });
    };
    /**
     * @method            module:azure-iot-device.Client#sendEvent
     * @description       The [sendEvent]{@link azure-iot-device.Client.sendEvent} method sends an event message
     *                    to the IoT Hub as the device indicated by the connection string passed
     *                    via the constructor.
     *
     * @param {azure-iot-common.Message}  message            The [message]{@link azure-iot-common.Message} to be sent.
     * @param {Function}                  sendEventCallback  The callback to be invoked when `sendEvent` completes execution.
     */
    Client.prototype.sendEvent = function (message, sendEventCallback) {
        var _this = this;
        var retryOp = new azure_iot_common_2.RetryOperation(this._retryPolicy, this._maxOperationTimeout);
        retryOp.retry(function (opCallback) {
            /*Codes_SRS_NODE_DEVICE_CLIENT_05_007: [The sendEvent method shall send the event indicated by the message argument via the transport associated with the Client instance.]*/
            _this._transport.sendEvent(message, opCallback);
        }, function (err, result) {
            safeCallback(sendEventCallback, err, result);
        });
    };
    /**
     * @method            module:azure-iot-device.Client#sendEventBatch
     * @description       The [sendEventBatch]{@link azure-iot-device.Client.sendEventBatch} method sends a list
     *                    of event messages to the IoT Hub as the device indicated by the connection
     *                    string passed via the constructor.
     *
     * @param {array<Message>} messages               Array of [Message]{@link azure-iot-common.Message}
     *                                                objects to be sent as a batch.
     * @param {Function}      sendEventBatchCallback  The callback to be invoked when
     *                                                `sendEventBatch` completes execution.
     */
    Client.prototype.sendEventBatch = function (messages, sendEventBatchCallback) {
        var _this = this;
        var retryOp = new azure_iot_common_2.RetryOperation(this._retryPolicy, this._maxOperationTimeout);
        retryOp.retry(function (opCallback) {
            /*Codes_SRS_NODE_DEVICE_CLIENT_05_008: [The sendEventBatch method shall send the list of events (indicated by the messages argument) via the transport associated with the Client instance.]*/
            _this._transport.sendEventBatch(messages, opCallback);
        }, function (err, result) {
            safeCallback(sendEventBatchCallback, err, result);
        });
    };
    /**
     * @method           module:azure-iot-device.Client#close
     * @description      The `close` method directs the transport to close the current connection to the IoT Hub instance
     *
     * @param {Function} closeCallback    The callback to be invoked when the connection has been closed.
     */
    Client.prototype.close = function (closeCallback) {
        this._closeTransport(function (err, result) {
            safeCallback(closeCallback, err, result);
        });
    };
    /**
     * @deprecated      Use Client.setOptions instead.
     * @method          module:azure-iot-device.Client#setTransportOptions
     * @description     The `setTransportOptions` method configures transport-specific options for the client and its underlying transport object.
     *
     * @param {Object}      options     The options that shall be set (see transports documentation).
     * @param {Function}    done        The callback that shall be invoked with either an error or a result object.
     */
    Client.prototype.setTransportOptions = function (options, done) {
        var _this = this;
        /*Codes_SRS_NODE_DEVICE_CLIENT_16_024: [The ‘setTransportOptions’ method shall throw a ‘ReferenceError’ if the options object is falsy] */
        if (!options)
            throw new ReferenceError('options cannot be falsy.');
        /*Codes_SRS_NODE_DEVICE_CLIENT_16_025: [The ‘setTransportOptions’ method shall throw a ‘NotImplementedError’ if the transport doesn’t implement a ‘setOption’ method.] */
        if (typeof this._transport.setOptions !== 'function')
            throw new azure_iot_common_1.errors.NotImplementedError('setOptions does not exist on this transport');
        var clientOptions = {
            http: {
                receivePolicy: options
            }
        };
        var retryOp = new azure_iot_common_2.RetryOperation(this._retryPolicy, this._maxOperationTimeout);
        retryOp.retry(function (opCallback) {
            /*Codes_SRS_NODE_DEVICE_CLIENT_16_021: [The ‘setTransportOptions’ method shall call the ‘setOptions’ method on the transport object.]*/
            _this._transport.setOptions(clientOptions, opCallback);
        }, function (err) {
            if (err) {
                safeCallback(done, err);
            }
            else {
                safeCallback(done, null, new azure_iot_common_1.results.TransportConfigured());
            }
        });
    };
    /**
     * @method          module:azure-iot-device.Client#setOptions
     * @description     The `setOptions` method let the user configure the client.
     *
     * @param  {Object}    options  The options structure
     * @param  {Function}  done     The callback that shall be called when setOptions is finished.
     *
     * @throws {ReferenceError}     If the options structure is falsy
     */
    Client.prototype.setOptions = function (options, done) {
        var _this = this;
        /*Codes_SRS_NODE_DEVICE_CLIENT_16_042: [The `setOptions` method shall throw a `ReferenceError` if the options object is falsy.]*/
        if (!options)
            throw new ReferenceError('options cannot be falsy.');
        // Making this an operation that can be retried because we cannot assume the transport's behavior (whether it's going to disconnect/reconnect, etc).
        var retryOp = new azure_iot_common_2.RetryOperation(this._retryPolicy, this._maxOperationTimeout);
        retryOp.retry(function (opCallback) {
            _this._transport.setOptions(options, opCallback);
        }, function (err) {
            /*Codes_SRS_NODE_DEVICE_CLIENT_16_043: [The `done` callback shall be invoked no parameters when it has successfully finished setting the client and/or transport options.]*/
            /*Codes_SRS_NODE_DEVICE_CLIENT_16_044: [The `done` callback shall be invoked with a standard javascript `Error` object and no result object if the client could not be configured as requested.]*/
            safeCallback(done, err);
        });
    };
    /**
     * @method           module:azure-iot-device.Client#complete
     * @description      The `complete` method directs the transport to settle the message passed as argument as 'completed'.
     *
     * @param {Message}  message           The message to settle.
     * @param {Function} completeCallback  The callback to call when the message is completed.
     *
     * @throws {ReferenceError} If the message is falsy.
     */
    Client.prototype.complete = function (message, completeCallback) {
        var _this = this;
        /*Codes_SRS_NODE_DEVICE_CLIENT_16_016: [The ‘complete’ method shall throw a ReferenceError if the ‘message’ parameter is falsy.] */
        if (!message)
            throw new ReferenceError('message is \'' + message + '\'');
        var retryOp = new azure_iot_common_2.RetryOperation(this._retryPolicy, this._maxOperationTimeout);
        retryOp.retry(function (opCallback) {
            _this._transport.complete(message, opCallback);
        }, function (err, result) {
            safeCallback(completeCallback, err, result);
        });
    };
    /**
     * @method           module:azure-iot-device.Client#reject
     * @description      The `reject` method directs the transport to settle the message passed as argument as 'rejected'.
     *
     * @param {Message}  message         The message to settle.
     * @param {Function} rejectCallback  The callback to call when the message is rejected.
     *
     * @throws {ReferenceException} If the message is falsy.
     */
    Client.prototype.reject = function (message, rejectCallback) {
        var _this = this;
        /*Codes_SRS_NODE_DEVICE_CLIENT_16_018: [The reject method shall throw a ReferenceError if the ‘message’ parameter is falsy.] */
        if (!message)
            throw new ReferenceError('message is \'' + message + '\'');
        var retryOp = new azure_iot_common_2.RetryOperation(this._retryPolicy, this._maxOperationTimeout);
        retryOp.retry(function (opCallback) {
            _this._transport.reject(message, opCallback);
        }, function (err, result) {
            safeCallback(rejectCallback, err, result);
        });
    };
    /**
     * @method           module:azure-iot-device.Client#abandon
     * @description      The `abandon` method directs the transport to settle the message passed as argument as 'abandoned'.
     *
     * @param {Message}  message          The message to settle.
     * @param {Function} abandonCallback  The callback to call when the message is abandoned.
     *
     * @throws {ReferenceException} If the message is falsy.
     */
    Client.prototype.abandon = function (message, abandonCallback) {
        var _this = this;
        /*Codes_SRS_NODE_DEVICE_CLIENT_16_017: [The abandon method shall throw a ReferenceError if the ‘message’ parameter is falsy.] */
        if (!message)
            throw new ReferenceError('message is \'' + message + '\'');
        var retryOp = new azure_iot_common_2.RetryOperation(this._retryPolicy, this._maxOperationTimeout);
        retryOp.retry(function (opCallback) {
            _this._transport.abandon(message, opCallback);
        }, function (err, result) {
            safeCallback(abandonCallback, err, result);
        });
    };
    /**
     * @method           module:azure-iot-device.Client#uploadToBlob
     * @description      The `uploadToBlob` method uploads a stream to a blob.
     *
     * @param {String}   blobName         The name to use for the blob that will be created with the content of the stream.
     * @param {Stream}   stream           The data to that should be uploaded to the blob.
     * @param {Number}   streamLength     The size of the data to that should be uploaded to the blob.
     * @param {Function} done             The callback to call when the upload is complete.
     *
     * @throws {ReferenceException} If blobName or stream or streamLength is falsy.
     */
    Client.prototype.uploadToBlob = function (blobName, stream, streamLength, done) {
        var _this = this;
        /*Codes_SRS_NODE_DEVICE_CLIENT_16_037: [The `uploadToBlob` method shall throw a `ReferenceError` if `blobName` is falsy.]*/
        if (!blobName)
            throw new ReferenceError('blobName cannot be \'' + blobName + '\'');
        /*Codes_SRS_NODE_DEVICE_CLIENT_16_038: [The `uploadToBlob` method shall throw a `ReferenceError` if `stream` is falsy.]*/
        if (!stream)
            throw new ReferenceError('stream cannot be \'' + stream + '\'');
        /*Codes_SRS_NODE_DEVICE_CLIENT_16_039: [The `uploadToBlob` method shall throw a `ReferenceError` if `streamLength` is falsy.]*/
        if (!streamLength)
            throw new ReferenceError('streamLength cannot be \'' + streamLength + '\'');
        var retryOp = new azure_iot_common_2.RetryOperation(this._retryPolicy, this._maxOperationTimeout);
        retryOp.retry(function (opCallback) {
            /*Codes_SRS_NODE_DEVICE_CLIENT_16_040: [The `uploadToBlob` method shall call the `done` callback with an `Error` object if the upload fails.]*/
            /*Codes_SRS_NODE_DEVICE_CLIENT_16_041: [The `uploadToBlob` method shall call the `done` callback no parameters if the upload succeeds.]*/
            _this.blobUploadClient.uploadToBlob(blobName, stream, streamLength, opCallback);
        }, function (err, result) {
            safeCallback(done, err, result);
        });
    };
    /**
     * @method           module:azure-iot-device.Client#getTwin
     * @description      The `getTwin` method creates a Twin object and establishes a connection with the Twin service.
     *
     * @param {Function} done             The callback to call when the connection is established.
     *
     */
    Client.prototype.getTwin = function (done, twin) {
        /* Codes_SRS_NODE_DEVICE_CLIENT_18_001: [** The `getTwin` method shall call the `azure-iot-device-core!Twin.fromDeviceClient` method to create the device client object. **]** */
        /* Codes_SRS_NODE_DEVICE_CLIENT_18_002: [** The `getTwin` method shall pass itself as the first parameter to `fromDeviceClient` and it shall pass the `done` method as the second parameter. **]**  */
        /* Codes_SRS_NODE_DEVICE_CLIENT_18_003: [** The `getTwin` method shall use the second parameter (if it is not falsy) to call `fromDeviceClient` on. **]**    */
        (twin || require('./twin.js').Twin).fromDeviceClient(this, done);
    };
    /**
     * Sets the retry policy used by the client on all operations. The default is {@link azure-iot-common.ExponentialBackoffWithJitter|ExponentialBackoffWithJitter}.
     * @param policy {RetryPolicy}  The retry policy that should be used for all future operations.
     */
    Client.prototype.setRetryPolicy = function (policy) {
        /*Codes_SRS_NODE_DEVICE_CLIENT_16_083: [The `setRetryPolicy` method shall throw a `ReferenceError` if the policy object is falsy.]*/
        if (!policy) {
            throw new ReferenceError('\'policy\' cannot be \'' + policy + '\'');
        }
        else {
            /*Codes_SRS_NODE_DEVICE_CLIENT_16_084: [The `setRetryPolicy` method shall throw an `ArgumentError` if the policy object doesn't have a `shouldRetry` method.]*/
            /*Codes_SRS_NODE_DEVICE_CLIENT_16_085: [The `setRetryPolicy` method shall throw an `ArgumentError` if the policy object doesn't have a `nextRetryTimeout` method.]*/
            if (typeof policy.shouldRetry !== 'function' || typeof policy.nextRetryTimeout !== 'function') {
                throw new azure_iot_common_1.errors.ArgumentError('A policy object must have a maxTimeout property that is a number and a nextRetryTimeout method.');
            }
        }
        /*Codes_SRS_NODE_DEVICE_CLIENT_16_086: [Any operation happening after a `setRetryPolicy` call should use the policy set during that call.]*/
        this._retryPolicy = policy;
    };
    Client.prototype._validateDeviceMethodInputs = function (methodName, callback) {
        // Codes_SRS_NODE_DEVICE_CLIENT_13_020: [ onDeviceMethod shall throw a ReferenceError if methodName is falsy. ]
        if (!methodName) {
            throw new ReferenceError('methodName cannot be \'' + methodName + '\'');
        }
        // Codes_SRS_NODE_DEVICE_CLIENT_13_024: [ onDeviceMethod shall throw a TypeError if methodName is not a string. ]
        if (typeof (methodName) !== 'string') {
            throw new TypeError('methodName\'s type is \'' + typeof (methodName) + '\'. A string was expected.');
        }
        // Codes_SRS_NODE_DEVICE_CLIENT_13_022: [ onDeviceMethod shall throw a ReferenceError if callback is falsy. ]
        if (!callback) {
            throw new ReferenceError('callback cannot be \'' + callback + '\'');
        }
        // Codes_SRS_NODE_DEVICE_CLIENT_13_025: [ onDeviceMethod shall throw a TypeError if callback is not a Function. ]
        if (typeof (callback) !== 'function') {
            throw new TypeError('callback\'s type is \'' + typeof (callback) + '\'. A function reference was expected.');
        }
        // Codes_SRS_NODE_DEVICE_CLIENT_13_023: [ onDeviceMethod shall throw an Error if a listener is already subscribed for a given method call. ]
        if (!!(this._methodCallbackMap[methodName])) {
            throw new Error('A handler for this method has already been registered with the client.');
        }
    };
    Client.prototype._addMethodCallback = function (methodName, callback) {
        var self = this;
        this._transport.onDeviceMethod(methodName, function (message) {
            // build the request object
            var request = new device_method_1.DeviceMethodRequest(message.requestId, message.methods.methodName, message.body);
            // build the response object
            var response = new device_method_1.DeviceMethodResponse(message.requestId, self._transport);
            // Codes_SRS_NODE_DEVICE_CLIENT_13_001: [ The onDeviceMethod method shall cause the callback function to be invoked when a cloud-to-device method invocation signal is received from the IoT Hub service. ]
            callback(request, response);
        });
    };
    Client.prototype._enableC2D = function (callback) {
        var _this = this;
        if (!this._c2dEnabled) {
            var retryOp = new azure_iot_common_2.RetryOperation(this._retryPolicy, this._maxOperationTimeout);
            retryOp.retry(function (opCallback) {
                _this._transport.enableC2D(opCallback);
            }, function (err) {
                if (!err) {
                    _this._c2dEnabled = true;
                }
                callback(err);
            });
        }
        else {
            callback();
        }
    };
    Client.prototype._disableC2D = function (callback) {
        var _this = this;
        if (this._c2dEnabled) {
            this._transport.disableC2D(function (err) {
                if (!err) {
                    _this._c2dEnabled = false;
                }
                callback(err);
            });
        }
        else {
            callback();
        }
    };
    Client.prototype._enableMethods = function (callback) {
        var _this = this;
        if (!this._methodsEnabled) {
            var retryOp = new azure_iot_common_2.RetryOperation(this._retryPolicy, this._maxOperationTimeout);
            retryOp.retry(function (opCallback) {
                _this._transport.enableMethods(opCallback);
            }, function (err) {
                if (!err) {
                    _this._methodsEnabled = true;
                }
                callback(err);
            });
        }
        else {
            callback();
        }
    };
    // Currently there is no code making use of this function, because there is no "removeDeviceMethod" corresponding to "onDeviceMethod"
    // private _disableMethods(callback: (err?: Error) => void): void {
    //   if (this._methodsEnabled) {
    //     this._transport.disableMethods((err) => {
    //       if (!err) {
    //         this._methodsEnabled = false;
    //       }
    //       callback(err);
    //     });
    //   } else {
    //     callback();
    //   }
    // }
    Client.prototype._renewSharedAccessSignature = function () {
        var _this = this;
        var cn = ConnectionString.parse(this._connectionString);
        var sas = SharedAccessSignature.create(cn.HostName, cn.DeviceId, cn.SharedAccessKey, azure_iot_common_1.anHourFromNow());
        this.updateSharedAccessSignature(sas.toString(), function (err) {
            if (_this._useAutomaticRenewal) {
                _this._sasRenewalTimeout = setTimeout(_this._renewSharedAccessSignature.bind(_this), Client.sasRenewalInterval);
            }
            if (err) {
                /*Codes_SRS_NODE_DEVICE_CLIENT_16_006: [The ‘error’ event shall be emitted when an error occurred within the client code.] */
                _this.emit('error', err);
            }
            else {
                _this.emit('_sharedAccessSignatureUpdated');
            }
        });
    };
    Client.prototype._closeTransport = function (closeCallback) {
        var _this = this;
        var onDisconnected = function (err, result) {
            /*Codes_SRS_NODE_DEVICE_CLIENT_16_056: [The `close` method shall not throw if the `closeCallback` is not passed.]*/
            /*Codes_SRS_NODE_DEVICE_CLIENT_16_055: [The `close` method shall call the `closeCallback` function when done with either a single Error object if it failed or null and a results.Disconnected object if successful.]*/
            safeCallback(closeCallback, err, result);
        };
        if (this._sasRenewalTimeout) {
            clearTimeout(this._sasRenewalTimeout);
        }
        this._disableC2D(function () {
            /*Codes_SRS_NODE_DEVICE_CLIENT_16_001: [The `close` function shall call the transport's `disconnect` function if it exists.]*/
            _this._transport.disconnect(function (disconnectError, disconnectResult) {
                /*Codes_SRS_NODE_DEVICE_CLIENT_16_046: [The `close` method shall remove the listener that has been attached to the transport `disconnect` event.]*/
                _this._transport.removeListener('disconnect', _this._disconnectHandler);
                onDisconnected(disconnectError, disconnectResult);
            });
        });
    };
    /**
     * @method            module:azure-iot-device.Client.fromConnectionString
     * @description       Creates an IoT Hub device client from the given
     *                    connection string using the given transport type.
     *
     * @param {String}    connStr       A connection string which encapsulates "device
     *                                  connect" permissions on an IoT hub.
     * @param {Function}  Transport     A transport constructor.
     *
     * @throws {ReferenceError}         If the connStr parameter is falsy.
     *
     * @returns {module:azure-iothub.Client}
     */
    Client.fromConnectionString = function (connStr, transportCtor) {
        /*Codes_SRS_NODE_DEVICE_CLIENT_05_003: [The fromConnectionString method shall throw ReferenceError if the connStr argument is falsy.]*/
        if (!connStr)
            throw new ReferenceError('connStr is \'' + connStr + '\'');
        /*Codes_SRS_NODE_DEVICE_CLIENT_05_005: [fromConnectionString shall derive and transform the needed parts from the connection string in order to create a new instance of transportCtor.]*/
        var cn = ConnectionString.parse(connStr);
        var config = {
            host: cn.HostName,
            deviceId: cn.DeviceId
        };
        if (cn.hasOwnProperty('SharedAccessKey')) {
            var sas = SharedAccessSignature.create(cn.HostName, cn.DeviceId, cn.SharedAccessKey, azure_iot_common_1.anHourFromNow());
            config.sharedAccessSignature = sas.toString();
        }
        /*Codes_SRS_NODE_DEVICE_CLIENT_05_006: [The fromConnectionString method shall return a new instance of the Client object, as by a call to new Client(new transportCtor(...)).]*/
        return new Client(new transportCtor(config), connStr, new blob_upload_1.BlobUploadClient(config));
    };
    /**
     * @method            module:azure-iot-device.Client.fromSharedAccessSignature
     * @description       Creates an IoT Hub device client from the given
     *                    shared access signature using the given transport type.
     *
     * @param {String}    sharedAccessSignature      A shared access signature which encapsulates "device
     *                                  connect" permissions on an IoT hub.
     * @param {Function}  Transport     A transport constructor.
     *
     * @throws {ReferenceError}         If the connStr parameter is falsy.
     *
     * @returns {module:azure-iothub.Client}
     */
    Client.fromSharedAccessSignature = function (sharedAccessSignature, transportCtor) {
        /*Codes_SRS_NODE_DEVICE_CLIENT_16_029: [The fromSharedAccessSignature method shall throw a ReferenceError if the sharedAccessSignature argument is falsy.] */
        if (!sharedAccessSignature)
            throw new ReferenceError('sharedAccessSignature is \'' + sharedAccessSignature + '\'');
        var sas = SharedAccessSignature.parse(sharedAccessSignature);
        var decodedUri = decodeURIComponent(sas.sr);
        var uriSegments = decodedUri.split('/');
        var config = {
            host: uriSegments[0],
            deviceId: uriSegments[uriSegments.length - 1],
            sharedAccessSignature: sharedAccessSignature
        };
        /*Codes_SRS_NODE_DEVICE_CLIENT_16_030: [The fromSharedAccessSignature method shall return a new instance of the Client object] */
        return new Client(new transportCtor(config), null, new blob_upload_1.BlobUploadClient(config));
    };
    // SAS token created by the client have a lifetime of 60 minutes, renew every 45 minutes
    /**
     * @private
     */
    Client.sasRenewalInterval = 2700000;
    return Client;
}(events_1.EventEmitter));
exports.Client = Client;
//# sourceMappingURL=client.js.map